{"version":3,"sources":["file:///Users/songxiangying/Library/Containers/com.tencent.xinWeChat/Data/Documents/xwechat_files/wxid_4kr9sthln3gq22_cb54/msg/file/2025-11/cc123/assets/core/glass-anims/GlassPourOut.ts"],"names":["_decorator","Animation","AnimationClip","Color","Node","Sprite","tween","UIOpacity","v3","Vec3","Glass","WaterColors","Toolkit","ccclass","menu","property","GlassPourOut","startColumnIndex","_eventCallbacks","isPourOutCompleted","on","event","callback","init","info","flowingSprites","forEach","sprite","node","active","pickUpMoveTo","from","to","oriPosition","clone","scale","x","worldPosition","start","shadowNode","position","targetX","targetPos","z","uiOpacity","getComponent","opacity","frontNode","putDownBack","layerID","speed","tw","waitForTween","pourOutFinish","currentLayerIdx","i","watersNode","children","animState","anim","getState","defaultClip","name","currentTime","time","pause","wrapMode","WrapMode","Reverse","duration","resume","completePour","waters","recycle","showNextLayerSurface","index","nextIndex","nextNode","pourOutStart","layerIdx","length","colorIdx","startPour","color","fromHEX","base","resetAnim","Normal","initAnimationParams","addWaters","play","showSurface"],"mappings":"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","sourcesContent":["/**\n * @Descripttion:\n * @version: 1.0\n * @Author: Lioesquieu\n * @Date: 2025-07-20\n * @LastEditors: Lioesquieu\n * @LastEditTime: 2025-07-22\n */\nimport {_decorator, Animation, AnimationClip, Color, math, Node, Sprite, tween, UIOpacity, v3, Vec3} from 'cc';\nimport Glass from \"../Glass\";\nimport {WaterColor, WaterColors} from \"../CwgConstant\";\nimport Toolkit from '../../common/Toolkit';\nimport { GlassInfo } from '../FunlandInfo';\n\nconst {ccclass, menu, property} = _decorator;\n\n\n@ccclass('GlassPourOut')\n@menu('cwg/GlassPourOut')\nexport default class GlassPourOut extends Glass {\n\n    /** Animation component reference */\n    @property(Animation)\n    protected anim: Animation;\n\n    /** Reflection on the front of the glass */\n    @property(Node)\n    protected frontNode: Node;\n\n    @property([Sprite])\n    protected flowingSprites: Sprite[] = [];\n\n    /** Starting column index (0-based) */\n    protected startColumnIndex: number = 0;\n\n    private _eventCallbacks: { [event: string]: (layerIdx: number, color: WaterColor) => void } = {};\n\n    /**\n     * Register event callback\n     * @param event Event type: 'startPour' | 'completePour'\n     * @param callback Callback function\n     * @returns this\n     */\n    public on(event: 'startPour' | 'completePour', callback: (layerIdx: number, color: WaterColor) => void): this {\n        this._eventCallbacks[event] = callback;\n        return this;\n    }\n\n    /** Whether the pouring process is completed */\n    protected isPourOutCompleted: boolean = false;\n\n    /** Cache of the glass's original position */\n    protected oriPosition: math.Vec3;\n\n    public init(info: GlassInfo): void {\n        super.init(info);\n        this.flowingSprites.forEach((sprite) => {\n            sprite.node.active = false;\n        })\n    }\n\n    /**\n     * Pickup and move the glass to the target position\n     * @param from Starting world coordinates\n     * @param to Target world coordinates\n     */\n    public pickUpMoveTo(from: math.Vec3, to: Readonly<Vec3>) {\n        this.oriPosition = from.clone();\n        if (this.node.scale.x < 0) {\n            this.oriPosition.x -= 17.244 * 2;\n        }\n        this.node.worldPosition = from;\n        tween(this.node).to(0.666, {worldPosition: to}).start();\n\n        // Shadow flies away\n        if (this.shadowNode) {\n            this.shadowNode.position = v3(0, 0, 0);\n            \n            // [Fix] Use Vec3 and position property for tween to avoid type error\n            const targetX = 380 * this.node.scale.x;\n            const targetPos = new Vec3(targetX, 22, this.shadowNode.position.z);\n            tween(this.shadowNode).to(0.3, { position: targetPos }).start();\n\n            const uiOpacity = this.shadowNode.getComponent(UIOpacity);\n            if (uiOpacity) {\n                tween(uiOpacity).to(0.3, {opacity: 0}).start();\n            }\n        }\n        this.frontNode.scale = this.node.scale;\n    }\n\n    /**\n     * Put the glass back to its original position\n     * @returns Promise that resolves when movement is complete\n     */\n    public putDownBack() {\n        const layerID = this.startColumnIndex + 1;\n        const speed = [0, 6, 5, 4, 3][layerID];\n        const tw = tween(this.node).to((0.666 + ((5 - layerID) * 0.333)) / speed, {worldPosition: this.oriPosition});\n        return Toolkit.waitForTween(tw);\n    }\n\n    /**\n     * Handle pour out complete event\n     * @param currentLayerIdx Current liquid layer Index\n     */\n    protected pourOutFinish(currentLayerIdx: number) {\n        if (this.isPourOutCompleted) {\n            return;\n        }\n        if (currentLayerIdx == this.startColumnIndex) {\n            // Hide the water that has been poured out\n            for (let i = 3; i >= this.startColumnIndex; i--) {\n                this.watersNode.children[i].active = false;\n            }\n\n            const animState = this.anim.getState(this.anim.defaultClip.name);\n            const currentTime = animState.time; // Get current playback time\n\n            this.anim.pause();  // Pause animation\n            // Set reverse playback mode and time\n            animState.wrapMode = AnimationClip.WrapMode.Reverse;\n            animState.time = animState.duration - currentTime;\n            animState.speed = [6, 5, 4, 3][currentLayerIdx]; // Reverse playback speed\n            this.anim.resume(); // Start reverse playback\n\n            // Pouring completed (trigger complete event)\n            // At this time, it is still in the state of returning to upright\n            this.isPourOutCompleted = true;\n            this._eventCallbacks.completePour?.(currentLayerIdx, this.waters[currentLayerIdx]);\n            this.recycle();\n        } else {\n            // Show the water surface of the layer below\n            this.showNextLayerSurface(currentLayerIdx);\n        }\n    }\n\n    /**\n     * Show the water surface of the next layer\n     * @param currentLayerIdx Current liquid layer Index (0-based)\n     */\n    protected showNextLayerSurface(index: number) {\n        const nextIndex = index - 1;\n        if (nextIndex >= 0) {\n            const nextNode = this.watersNode.children[nextIndex];\n            if (nextNode.active) {\n                nextNode.children[0].active = true;\n            }\n        }\n    }\n\n    /**\n     * Handle pour out start event\n     * @param layerID ID of the liquid layer currently being operated on\n     */\n    protected pourOutStart(layerIdx: number) {\n        if (this.isPourOutCompleted) {\n            return;\n        }\n        if (layerIdx >= this.startColumnIndex && layerIdx < this.waters.length) {\n\n            const colorIdx = this.waters[layerIdx];\n            this._eventCallbacks.startPour?.(layerIdx, colorIdx);\n            const color = new Color().fromHEX(WaterColors[colorIdx].base);\n            this.flowingSprites.forEach((sprite) => {\n                sprite.node.active = true;\n                sprite.color = color;\n            })\n        }\n    }\n\n    /**\n     * Reset animation state to initial values\n     */\n    protected resetAnim() {\n        const animState = this.anim.getState(this.anim.defaultClip.name);\n        animState.speed = 1; // Reset playback speed\n        animState.time = 0;  // Reset playback position\n        animState.wrapMode = AnimationClip.WrapMode.Normal;\n    }\n\n    private initAnimationParams(addWaters: WaterColor[]) {\n        this.isPourOutCompleted = false;\n        this.startColumnIndex = this.waters.length - addWaters.length;\n    }\n\n    /**\n     * Play pour out animation\n     * Returns a chainable object\n     * @param addWaters Array of water colors to add\n     * @returns Promise that resolves when animation is complete\n     */\n    public play(addWaters: WaterColor[]) {\n        this.resetAnim();\n\n        // Initialize animation parameters\n        this.initAnimationParams(addWaters);\n\n        this.showSurface();\n        this.anim.play();\n\n        return this;\n    }\n\n    // Clean up callbacks in recycle method\n    public recycle() {\n        this._eventCallbacks = {};\n        this.flowingSprites.forEach((sprite) => {\n            sprite.node.active = false;\n        })\n    }\n}"]}